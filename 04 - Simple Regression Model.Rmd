---
title: "03 - Simple Regression Model"
author: "Murray"
date: "5/9/2020"
output: html_document
---

GLM Predicts deaths x days after initial outbreak given average age, GDP (PPP), and Obesity rate. m2 is the best and then one I've been using.

Other options:

  Total Number of deaths t days after 1st infection.
  Total Number of deaths t days after infections crossed 0.1 per million people.
  
Could use t as a choice before fitting the model, or as an independent variable. In latter case watch out for non-linearity of relationship.

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())
library(ciTools)
library(tidyverse)

simple_model_data <- readRDS("03_Workspace/simple_model_data.Rds")
```

```{r}
model_variables <- simple_model_data %>%
  group_by(Country) %>%
  mutate(average_gov_response = mean(case_when(days_since_deaths_crossed_0.1_per_million >= 0 & date <= "2020-05-09" ~ StringencyIndex,
                                               TRUE ~ NaN), na.rm = T)) %>%
  group_by(Country, Obesity_rate, gdp_estimate_ppp, Median_Age, population_size, peak_deaths_already_occurred_indicator,
           risk_adjusted_age, Density_km, Inequality_spatial_transformed, gov_response_at_0.1_deaths_per_million, average_gov_response) %>%
  mutate(total_deaths = max(total_deaths, na.rm = T)) %>%
  filter(deaths_5_day_averages == max(deaths_5_day_averages, na.rm = T)) %>% # Just keeps the day(s) of the peak for each country
  summarise(total_deaths_per_million = max(total_deaths_per_million, na.rm = T),
            smooth_new_deaths_per_million = max(deaths_5_day_averages, na.rm = T),
            total_deaths = max(total_deaths, na.rm = T)) %>%
  filter(!is.na(Obesity_rate) &
         #!is.na(gdp_estimate_ppp) &
         !is.na(total_deaths_per_million) &
         !is.na(risk_adjusted_age) &
         !(is.na(Density_km)) &
         !is.na(gov_response_at_0.1_deaths_per_million) &
         peak_deaths_already_occurred_indicator == 1 &
         population_size >= 3 &
         total_deaths >= 50 &
         Country != c("China")
         ) %>%
  mutate(combined_density_measure = Density_km * Inequality_spatial_transformed)

write.csv(simple_model_data, file = "daily_country_data.csv")
write.csv(model_variables, file = "condensed_data_for_model.csv")

# Check distributions of independent variables

# ggplot(data = model_variables, aes(x = Obesity_rate)) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = risk_adjusted_age)) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = gdp_estimate_ppp)) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = Inequality_spatial_transformed)) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = log(Inequality_spatial_transformed))) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = log(risk_adjusted_age))) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = log(gdp_estimate_ppp))) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = sqrt(risk_adjusted_age))) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = sqrt(gdp_estimate_ppp))) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = risk_adjusted_age^(1/3))) +
#   geom_density()
# 
# ggplot(data = model_variables, aes(x = gdp_estimate_ppp^(1/3))) +
#   geom_density()
```

```{r}
# ggplot(data = model_variables, aes(x = gdp_estimate_ppp, y = total_deaths_per_million)) +
#   geom_line()

ggplot(data = model_variables, aes(x = Median_Age, y = total_deaths_per_million)) +
  geom_line()

ggplot(data = model_variables, aes(x = Obesity_rate, y = total_deaths_per_million)) +
  geom_line()
```

```{r}
# Just age
m1 <- glm(data = model_variables, family = Gamma("log"), formula = total_deaths_per_million ~ risk_adjusted_age)

# Include obesity
m2 <- glm(data = model_variables, family = Gamma("log"), formula = total_deaths_per_million ~ Obesity_rate + risk_adjusted_age)

# Include density info
m3 <- glm(data = model_variables, family = Gamma("log"),
          formula = total_deaths_per_million ~ Obesity_rate + risk_adjusted_age + Inequality_spatial_transformed)

m3b <- glm(data = model_variables, family = Gamma("log"),
          formula = total_deaths_per_million ~ Obesity_rate + Inequality_spatial_transformed)

m3c <- glm(data = model_variables, family = Gamma("log"),
          formula = total_deaths_per_million ~ Obesity_rate + risk_adjusted_age + combined_density_measure)

# Include gov response data
m4 <- glm(data = model_variables, family = Gamma("log"), formula = total_deaths_per_million ~ Obesity_rate + risk_adjusted_age + gov_response_at_0.1_deaths_per_million)

# Include all of above
m5 <- glm(data = model_variables, family = Gamma("log"),
          formula = total_deaths_per_million ~ Obesity_rate + risk_adjusted_age + gov_response_at_0.1_deaths_per_million + Inequality_spatial_transformed)

m5b <- glm(data = model_variables, family = Gamma("log"),
          formula = total_deaths_per_million ~ Obesity_rate + risk_adjusted_age + gdp_estimate_ppp + average_gov_response + Inequality_spatial_transformed)

# Compare
summary(m1)
summary(m2)
summary(m3)
summary(m3b)
summary(m3c)
summary(m4)
summary(m5)
summary(m5b)
```

```{r}
# predict.glm(m5, newdata = simple_model_data %>% filter((Country == "SouthAfrica") & date == "2020-05-11"), se.fit = T, type = "response")

# Let's predict all the countries we didn't include
predictions_vs_actual <- add_pi(tb = simple_model_data %>%
                                  filter(!(Country %in% model_variables$Country) & date == "2020-05-11") %>%
                                  mutate(total_deaths_per_million = 0), fit = m5) %>%
  select(Country, pred, LPB0.025, UPB0.975)

# 
# ggplot(data = predictions_vs_actual[order(predictions_vs_actual$pred),], aes(x = pred, y = total_deaths_per_million)) +
#     geom_line() + 
#     geom_ribbon(aes(ymin = LPB0.025, ymax = UPB0.975), alpha = 0.2) +
#     lims(y = c(0, 300))

# Compare fits to actual values
cbind.data.frame(model_variables %>% ungroup() %>% select(Country, total_deaths_per_million), m5$fitted.values)

# Correlation matrix of variables we included in m5. Only for countries in the model.
cor(model_variables %>% ungroup() %>% select(Obesity_rate, risk_adjusted_age, gdp_estimate_ppp, gov_response_at_0.1_deaths_per_million, Density_km, Inequality_spatial_transformed)) %>% View()
```

# Get fits for the different models

```{r}
ggplot(data = model_variables, aes(x = m2$fitted.values, y = total_deaths_per_million)) + 
  geom_point() +
  geom_text(aes(label = Country), size = 3, check_overlap = T, nudge_y = 7) +
  geom_line(aes(y = seq(0, 300, length.out = dim(model_variables)[1]), x = seq(0, 300, length.out = dim(model_variables)[1])), linetype = "dashed") +
  labs(title = "total_deaths_per_million ~ Obesity_rate + risk_adjusted_age",
       subtitle = "For countries that have observed a peak in deaths and have population > 3 million",
       x = "Fitted Values",
       y = "Actual Values")

ggplot(data = model_variables, aes(x = m5$fitted.values, y = total_deaths_per_million)) + 
  geom_point() +
  geom_text(aes(label = Country), size = 3, check_overlap = T, nudge_y = 7) +
  geom_line(aes(y = seq(0, 300, length.out = dim(model_variables)[1]), x = seq(0, 300, length.out = dim(model_variables)[1])), linetype = "dashed") +
  labs(title = "DPM ~ Obesity_rate + risk_adjusted_age + gov_response + spatial_inequality",
       subtitle = "For countries that have observed a peak in deaths and have population > 3 million",
       x = "Fitted Values",
       y = "Actual Values")
```

# Check residuals

```{r}
plot(m5)
```

# Save

